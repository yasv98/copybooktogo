package generate

import (
	"testing"

	"github.com/stretchr/testify/assert"

	"copybooktogo/parse"
)

func Test_GenerateGoStructsData(t *testing.T) {
	tests := map[string]struct {
		input       []*parse.Record
		expected    []byte
		assertError assert.ErrorAssertionFunc
	}{
		"Valid_Copybook_ReturnsGoStructs": {
			input: []*parse.Record{
				{
					Level:      1,
					Identifier: "RECORD-1",
					Children: []*parse.Record{
						{
							Level:      3,
							Identifier: "RECORD-2",
							Pic:        parse.Picture{PicString: "X(01)", PicType: parse.Alpha, PicCount: 1},
						},
						{
							Level:      3,
							Identifier: "FILLER",
							Children: []*parse.Record{
								{
									Level:       5,
									Identifier:  "RECORD-3",
									OccursCount: 10,
									Children: []*parse.Record{
										{
											Level:      7,
											Identifier: "RECORD-4",
											Pic:        parse.Picture{PicString: "S9(07)", PicType: parse.Signed, PicCount: 8},
										},
									},
								},
							},
						},
					},
				},
				{
					Level:      1,
					Identifier: "RECORD-5",
					Children: []*parse.Record{
						{
							Level:      5,
							Identifier: "FILLER",
							Pic:        parse.Picture{PicString: "X(02)", PicType: parse.Alpha, PicCount: 2},
						},
						{
							Level:      5,
							Identifier: "RECORD-6",
							Pic:        parse.Picture{PicString: "X(05)", PicType: parse.Alpha, PicCount: 5},
						},
						{
							Level:      5,
							Identifier: "FILLER",
							Pic:        parse.Picture{PicString: "X(05)", PicType: parse.Alpha, PicCount: 5},
							Redefines:  "RECORD-6",
						},
					},
				},
			},
			expected: []byte(`// This file is generated by copybooktogo. DO NOT EDIT.

package main

// Copybook contains a representation of Copybook
type Copybook struct {
	Record1 Record1 ` + "`pic:\"1,81,clause=X(81)\"`" + `  // start:1 end:81
	Record5 Record5 ` + "`pic:\"82,88,clause=X(07)\"`" + ` // start:82 end:88
}

// Record1 contains a representation of RECORD-1
type Record1 struct {
	Record2        string         ` + "`pic:\"1,1,clause=X(01)\"`" + `  // start:1 end:1
	Record1Filler1 Record1Filler1 ` + "`pic:\"2,81,clause=X(80)\"`" + ` // start:2 end:81
}

// Record1Filler1 contains a representation of RECORD-1-FILLER1
type Record1Filler1 struct {
	Record3 [10]Record3 ` + "`pic:\"1,80,10,clause=X(08)\"`" + ` // start:2 end:81
}

// Record3 contains a representation of RECORD-3
type Record3 struct {
	Record4 int ` + "`pic:\"1,8,clause=S9(07)\"`" + ` // start:2 end:9
}

// Record5 contains a representation of RECORD-5
type Record5 struct {
	Record5Filler1 string ` + "`pic:\"1,2,clause=X(02)\"`" + ` // start:82 end:83
	Record6        string ` + "`pic:\"3,7,clause=X(05)\"`" + ` // start:84 end:88
	Record5Filler2 string ` + "`pic:\"3,7,clause=X(05)\"`" + ` // start:84 end:88 REDEFINES Record6
}
`),
			assertError: assert.NoError,
		},
		"Valid_CopybookWithDecimal_ReturnsGoStructsWithGoPicDecimalImported": {
			input: []*parse.Record{
				{
					Level:      1,
					Identifier: "RECORD-1",
					Children: []*parse.Record{
						{
							Level:      5,
							Identifier: "RECORD-2",
							Pic:        parse.Picture{PicString: "9(15)V99", PicType: parse.Decimal, PicCount: 18},
						},
					},
				},
			},
			expected: []byte(`// This file is generated by copybooktogo. DO NOT EDIT.

package main

import (
	"github.com/anzx/fabric-go-pic/pkg/decimal"
)

// Copybook contains a representation of Copybook
type Copybook struct {
	Record1 Record1 ` + "`pic:\"1,18,clause=X(18)\"`" + ` // start:1 end:18
}

// Record1 contains a representation of RECORD-1
type Record1 struct {
	Record2 decimal.Decimal ` + "`pic:\"1,18,clause=9(15)V99\"`" + ` // start:1 end:18
}
`),
			assertError: assert.NoError,
		},
		"Invalid_EmptyCopybook_ReturnsError": {
			input:       []*parse.Record{},
			expected:    nil,
			assertError: assert.Error,
		},
	}

	for name, test := range tests {
		tt := test
		t.Run(name, func(t *testing.T) {
			got, err := ToGoStructsData(tt.input, "Copybook", "main")
			tt.assertError(t, err)
			assert.Equal(t, got, tt.expected)
		})
	}
}

func Test_buildFieldsData(t *testing.T) {
	tests := map[string]struct {
		parentName string
		records    []*parse.Record
		expected   []FieldData
	}{
		"SingleField": {
			records: []*parse.Record{
				{
					Level:      3,
					Identifier: "RECORD-2",
					Pic:        parse.Picture{PicString: "X(10)", PicType: parse.Alpha, PicCount: 10},
				},
			},
			expected: []FieldData{
				{
					FieldVarName:   "Record2",
					VarType:        "string",
					PicSize:        10,
					PicTag:         "1,10,clause=X(10)",
					PicGlobalStart: 1,
					PicGlobalEnd:   10,
				},
			},
		},
		"MultipleFields": {
			records: []*parse.Record{
				{
					Level:      5,
					Identifier: "RECORD-1",
					Pic:        parse.Picture{PicString: "X(10)", PicType: parse.Alpha, PicCount: 10},
				},
				{
					Level:       5,
					Identifier:  "RECORD-2",
					OccursCount: 2,
					Children: []*parse.Record{
						{
							Level:      7,
							Identifier: "RECORD-3",
							Pic:        parse.Picture{PicString: "X(05)", PicType: parse.Alpha, PicCount: 5},
						},
					},
				},
				{
					Level:      5,
					Identifier: "RECORD-4",
					Pic:        parse.Picture{PicString: "9(15)V99", PicType: parse.Decimal, PicCount: 18},
				},
			},
			expected: []FieldData{
				{
					FieldVarName:   "Record1",
					VarType:        "string",
					PicSize:        10,
					PicTag:         "1,10,clause=X(10)",
					PicGlobalStart: 1,
					PicGlobalEnd:   10,
				},
				{
					FieldVarName:   "Record2",
					VarType:        "[2]Record2",
					PicSize:        10,
					PicTag:         "11,20,2,clause=X(05)",
					PicGlobalStart: 11,
					PicGlobalEnd:   20,
				},
				{
					FieldVarName:   "Record4",
					VarType:        "decimal.Decimal",
					PicSize:        18,
					PicTag:         "21,38,clause=9(15)V99",
					PicGlobalStart: 21,
					PicGlobalEnd:   38,
				},
			},
		},
		"MultipleFillerFields": {
			parentName: "PARENT-RECORD",
			records: []*parse.Record{
				{
					Level:      5,
					Identifier: "FILLER",
					Pic:        parse.Picture{PicString: "X(02)", PicType: parse.Alpha, PicCount: 2},
				},
				{
					Level:      5,
					Identifier: "FILLER",
					Pic:        parse.Picture{PicString: "X(05)", PicType: parse.Alpha, PicCount: 5},
				},
			},
			expected: []FieldData{
				{
					FieldVarName:   "ParentRecordFiller1",
					VarType:        "string",
					PicSize:        2,
					PicTag:         "1,2,clause=X(02)",
					PicGlobalStart: 1,
					PicGlobalEnd:   2,
				},
				{
					FieldVarName:   "ParentRecordFiller2",
					VarType:        "string",
					PicSize:        5,
					PicTag:         "3,7,clause=X(05)",
					PicGlobalStart: 3,
					PicGlobalEnd:   7,
				},
			},
		},
		"MultipleFieldsWithRedefinesPosChange": {
			parentName: "PARENT-RECORD",
			records: []*parse.Record{
				{
					Level:      5,
					Identifier: "RECORD-1",
					Pic:        parse.Picture{PicString: "X(10)", PicType: parse.Alpha, PicCount: 10},
				},
				{
					Level:      5,
					Identifier: "RECORD-2",
					Pic:        parse.Picture{PicString: "X(10)", PicType: parse.Alpha, PicCount: 10},
					Redefines:  "RECORD-1",
				},
				{
					Level:      5,
					Identifier: "RECORD-3",
					Pic:        parse.Picture{PicString: "9(15)V99", PicType: parse.Decimal, PicCount: 18},
				},
			},
			expected: []FieldData{
				{
					FieldVarName:   "Record1",
					VarType:        "string",
					PicSize:        10,
					PicTag:         "1,10,clause=X(10)",
					PicGlobalStart: 1,
					PicGlobalEnd:   10,
				},
				{
					FieldVarName:     "Record2",
					VarType:          "string",
					RedefinesVarName: "Record1",
					PicSize:          10,
					PicTag:           "1,10,clause=X(10)",
					PicGlobalStart:   1,
					PicGlobalEnd:     10,
				},
				{
					FieldVarName:   "Record3",
					VarType:        "decimal.Decimal",
					PicSize:        18,
					PicTag:         "11,28,clause=9(15)V99",
					PicGlobalStart: 11,
					PicGlobalEnd:   28,
				},
			},
		},
	}

	for name, test := range tests {
		tt := test
		t.Run(name, func(t *testing.T) {
			got := buildFieldsData(tt.records, tt.parentName, newPositionTracker())
			assert.Equal(t, tt.expected, got)
		})
	}
}

func Test_getVarType(t *testing.T) {
	tests := map[string]struct {
		rec      *parse.Record
		varName  string
		expected string
	}{
		"PicRecord": {
			rec:      &parse.Record{Pic: parse.Picture{PicType: parse.Alpha}},
			expected: "string",
		},
		"PicRecordWithOccurs": {
			rec:      &parse.Record{Pic: parse.Picture{PicType: parse.Alpha}, OccursCount: 3},
			expected: "[3]string",
		},
		"RecordWithChildren": {
			rec: &parse.Record{
				Children: []*parse.Record{
					{Pic: parse.Picture{PicType: parse.Alpha}},
				},
			},
			varName:  "Record",
			expected: "Record",
		},
		"OccursRecordWithChildren": {
			rec: &parse.Record{
				OccursCount: 3,
				Children: []*parse.Record{
					{Pic: parse.Picture{PicType: parse.Alpha}},
				},
			},
			varName:  "Record",
			expected: "[3]Record",
		},
	}

	for name, test := range tests {
		tt := test
		t.Run(name, func(t *testing.T) {
			got := getVarType(tt.rec, tt.varName)
			assert.Equal(t, tt.expected, got)
		})
	}
}

func Test_getPicSize(t *testing.T) {
	tests := map[string]struct {
		input       *parse.Record
		expected    int
		expectPanic bool
	}{
		"PicRecord": {
			input: &parse.Record{
				Pic: parse.Picture{PicCount: 5},
			},
			expected:    5,
			expectPanic: false,
		},
		"PicRecordWithOccurs": {
			input: &parse.Record{
				Pic:         parse.Picture{PicCount: 3},
				OccursCount: 4,
			},
			expected:    12,
			expectPanic: false,
		},
		"RecordWithChildren": {
			input: &parse.Record{
				Children: []*parse.Record{
					{Pic: parse.Picture{PicCount: 2}},
					{Pic: parse.Picture{PicCount: 3}},
				},
			},
			expected:    5,
			expectPanic: false,
		},
		"RecordWithNestedChildren": {
			input: &parse.Record{
				Children: []*parse.Record{
					{Pic: parse.Picture{PicCount: 10}},
					{Children: []*parse.Record{
						{Pic: parse.Picture{PicCount: 2}},
						{Pic: parse.Picture{PicCount: 3}},
					}},
				},
			},
			expected:    15,
			expectPanic: false,
		},
		"OccursRecordWithChildren": {
			input: &parse.Record{
				OccursCount: 3,
				Children: []*parse.Record{
					{Pic: parse.Picture{PicCount: 2}},
					{Pic: parse.Picture{PicCount: 3}},
				},
			},
			expected:    15,
			expectPanic: false,
		},
		"RecordWithChildRedefinesSameSize": {
			input: &parse.Record{
				Children: []*parse.Record{
					{Identifier: "REDEFINED-FIELD", Pic: parse.Picture{PicCount: 5}},
					{Pic: parse.Picture{PicCount: 5}, Redefines: "REDEFINED-FIELD"},
				},
			},
			expected:    5,
			expectPanic: false,
		},
		"RecordWithChildRedefinesThatChangesSize": {
			input: &parse.Record{
				Children: []*parse.Record{
					{Identifier: "REDEFINED-FIELD", Pic: parse.Picture{PicCount: 5}},
					{Pic: parse.Picture{PicCount: 6}, Redefines: "REDEFINED-FIELD"},
				},
			},
			expected:    6,
			expectPanic: false,
		},
		"InvalidRedefines_Panics": {
			input: &parse.Record{
				Identifier: "GROUP3",
				Children: []*parse.Record{
					{
						Identifier: "INVALID-REDEFINES",
						Redefines:  "NONEXISTENT",
						Pic:        parse.Picture{PicCount: 3},
					},
				},
			},
			expectPanic: true,
		},
	}

	for name, test := range tests {
		tt := test
		t.Run(name, func(t *testing.T) {
			if tt.expectPanic {
				assert.Panics(t, func() { calculateSize(tt.input) })
			} else {
				got := calculateSize(tt.input)
				assert.Equal(t, tt.expected, got)
			}
		})
	}
}

func Test_getPicTag(t *testing.T) {
	tests := map[string]struct {
		rec       *parse.Record
		fieldSize int
		expected  string
	}{
		"PicRecord": {
			rec: &parse.Record{
				Pic: parse.Picture{PicString: "X(05)"},
			},
			fieldSize: 5,
			expected:  "1,5,clause=X(05)",
		},
		"PicRecordWithOccurs": {
			rec: &parse.Record{
				Pic:         parse.Picture{PicString: "9(03)"},
				OccursCount: 4,
			},
			fieldSize: 12,
			expected:  "1,12,4,clause=9(03)",
		},
		"RecordWithChildren": {
			rec: &parse.Record{
				Children: []*parse.Record{
					{Pic: parse.Picture{PicCount: 2}},
					{Pic: parse.Picture{PicCount: 3}},
				},
			},
			fieldSize: 5,
			expected:  "1,5,clause=X(05)",
		},
		"OccursRecordWithChildren": {
			rec: &parse.Record{
				OccursCount: 3,
				Children: []*parse.Record{
					{Pic: parse.Picture{PicCount: 2}},
					{Pic: parse.Picture{PicCount: 3}},
				},
			},
			fieldSize: 15,
			expected:  "1,15,3,clause=X(05)",
		},
	}

	for name, test := range tests {
		tt := test
		t.Run(name, func(t *testing.T) {
			got := getPicTag(tt.rec, tt.fieldSize, 1)
			assert.Equal(t, tt.expected, got)
		})
	}
}

func TestPositionTracker_GetStoredPos(t *testing.T) {
	tracker := &positionTracker{
		recordStore: map[string]positionInfo{
			"FIELD1": {localStart: 1, globalStart: 1},
			"FIELD2": {localStart: 5, globalStart: 10},
		},
	}

	t.Run("ExistingIdentifier_ReturnsPositions", func(t *testing.T) {
		localStart, globalStart := tracker.getStoredPos("FIELD2")
		assert.Equal(t, 5, localStart)
		assert.Equal(t, 10, globalStart)
	})

	t.Run("NonExistingIdentifier_Panics", func(t *testing.T) {
		assert.Panics(t, func() { tracker.getStoredPos("NONEXISTENT") })
	})
}
